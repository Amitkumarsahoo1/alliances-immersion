= Building a Cloud-ready Microservice

In this exercise, you will construct a Pivotal CF ready, database-backed RESTful microservice based on http://projects.spring.io/spring-boot/[Spring Boot], http://projects.spring.io/spring-data/[Spring Data], and http://projects.spring.io/spring-cloud/[Spring Cloud].

== Prerequisites

* http://www.gradle.org/installation[Gradle]
* An IDE or text editor
* Git repository created during kick off

== Steps

=== Building the Application

. Browse to http://start.spring.io[Spring Initializr] and complete the form:
+
Group:: org.example
Artifact:: cities
Name:: cities
Description:: Demo project
Package name:: org.example.cities
Type:: Gradle project
Packaging:: Jar
Java Version:: 1.7
Language:: Java
Spring Boot Version:: 1.1.8
Project Dependencies:: Actuator, JPA, Rest Repositories, Web

+
Then click `Generate`. This will result in a zip file being downloaded to your workstation.

. Create a directory in your github repository to house your code, and unzip `starter.zip` into that directory.

. Optionally generate project files for your favorite IDE by running `gradle idea` or `gradle eclipse`. Then open the project in your editor or IDE of choice.

. Add a runtime dependency on the http://hsqldb.org/[HyperSQL in-memory database] to `build.gradle`:
+
[source,groovy]
----
dependencies {
    // ...
    runtime("org.hsqldb:hsqldb")
}
----

. Create the package `org.example.cities.model` and in that package create the class +City+. Into that file you can paste the following source code, which represents cities based on postal codes, global coordinates, etc:
+
[source,java]
----
@Entity
@Table(name="city")
public class City implements Serializable {
    private static final long serialVersionUID = 1L;

    @Id
    @GeneratedValue
    private long id;

    @Column(nullable = false)
    private String name;

    @Column(nullable = false)
    private String county;

    @Column(nullable = false)
    private String stateCode;

    @Column(nullable = false)
    private String postalCode;

    @Column
    private String latitude;

    @Column
    private String longitude;

    public String getName() { return name; }

    public void setName(String name) { this.name = name; }

    public String getPostalCode() { return postalCode; }

    public void setPostalCode(String postalCode) { this.postalCode = postalCode; }

    public long getId() { return id; }

    public void setId(long id) { this.id = id; }

    public String getStateCode() { return stateCode; }

    public void setStateCode(String stateCode) { this.stateCode = stateCode; }

    public String getCounty() { return county; }

    public void setCounty(String county) { this.county = county; }

    public String getLatitude() { return latitude; }

    public void setLatitude(String latitude) { this.latitude = latitude; }

    public String getLongitude() { return longitude; }

    public void setLongitude(String longitude) { this.longitude = longitude; }
}
----
+
Notice that we're using JPA annotations on the class and its fields. You'll need to use your IDE's features to add the appropriate import statements.

. Create the package `org.example.cities.repo` and in that package create the interface +CityRepository+. Paste the following code and add appropriate imports:
+
[source,java]
----
@RepositoryRestResource(collectionResourceRel = "cities", path = "cities")
public interface CityRepository extends PagingAndSortingRepository<City, Long> {
}
----

. Add JPA and REST Repository support to the `org.example.cities.Application` class that was generated by Spring Initializr.
+
[source,java]
----
@Configuration
@ComponentScan
@EnableAutoConfiguration
@EnableJpaRepositories // <---- Add this
@Import(RepositoryRestMvcConfiguration.class) // <---- And this
public class Application {

    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}
----

. Build the application:
+
[source,bash]
----
$ gradle assemble
----

. Run the application:
+
[source,bash]
----
$ java -jar build/libs/cities-0.0.1-SNAPSHOT.jar
----

. Access the application using +curl+. You'll see that the primary endpoint automatically exposes the ability to page, size, and sort the response JSON.
+
So what have you done? Created four small classes and one build file, resulting in a fully-functional REST microservice. The application's +DataSource+ is created automatically by Spring Boot using the in-memory database because no other +DataSource+ was detected in the project.
+
[source,bash]
----
$ curl -i localhost:8080/cities
HTTP/1.1 200 OK
Server: Apache-Coyote/1.1
X-Application-Context: application
Content-Type: application/hal+json
Transfer-Encoding: chunked
Date: Tue, 27 May 2014 19:34:45 GMT

{
  "_links" : {
    "self" : {
      "href" : "http://localhost:8080/cities{?page,size,sort}",
      "templated" : true
    }
  },
  "page" : {
    "size" : 20,
    "totalElements" : 0,
    "totalPages" : 0,
    "number" : 0
  }
}
----
+
Next we'll import some data.

==== Importing Data

. Shutdown the application.

. Add this link:https://raw.githubusercontent.com/spgreenberg/immersion-test/master/microservice/src/main/resources/import.sql[import.sql] file to `src/main/resources`. This is a dataset containing all of the postal codes in Colorado. This file will automatically be picked up by Hibernate and imported into the in-memory database.

. Build the application:
+
[source,bash]
----
$ gradle assemble
----

. Run the application:
+
[source,bash]
----
$ java -jar build/libs/cities-0.0.1-SNAPSHOT.jar
----

. Access the application again using +curl+. Notice the appropriate hypermedia is included for +next+, +previous+, and +self+. You can also select pages and page size by utilizing +?size=n&page=n+ on the URL string. Finally, you can sort the data utilizing +?sort=fieldName+.
+
[source,bash]
----
$ curl -i localhost:8080/cities
HTTP/1.1 200 OK
Server: Apache-Coyote/1.1
X-Application-Context: application
Content-Type: application/hal+json
Transfer-Encoding: chunked
Date: Tue, 27 May 2014 19:59:58 GMT

{
  "_links" : {
    "next" : {
      "href" : "http://localhost:8080/cities?page=1&size=20"
    },
    "self" : {
      "href" : "http://localhost:8080/cities{?page,size,sort}",
      "templated" : true
    }
  },

  ... RESULTS ...

  "page" : {
    "size" : 20,
    "totalElements" : 662,
    "totalPages" : 34,
    "number" : 0
  }
}
----

. Try the following +curl+ statements to see how the application behaves:
+
[source,bash]
----
$ curl -i "localhost:8080/cities?size=5"
$ curl -i "localhost:8080/cities?size=5&page=3"
$ curl -i "localhost:8080/cities?sort=postalCode,desc"
----

==== FYI: Using Spring Boot Actuator

Try out the following endpoints. The output is omitted here because it can be quite large:

http://localhost:8080/beans:: Dumps all of the beans in the Spring context.
http://localhost:8080/autoconfig:: Dumps all of the auto-configuration performed as part of application bootstrapping.
http://localhost:8080/env:: Dumps the application's shell environment as well as all Java system properties.
http://localhost:8080/metrics:: Dumps all metrics currently being collected by Actuator, primarily response time and access counts for endpoints.
http://localhost:8080/mappings:: Dumps all URI request mappings and the controller methods to which they are mapped.
