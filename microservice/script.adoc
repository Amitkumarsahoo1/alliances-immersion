= Building a Cloud-ready Microservice

In this exercise, you will construct a Pivotal CF ready, database-backed RESTful microservice based on http://projects.spring.io/spring-boot/[Spring Boot], http://projects.spring.io/spring-data/[Spring Data], and http://projects.spring.io/spring-cloud/[Spring Cloud].

== Prerequisites

* http://www.gradle.org/installation[Gradle]
* An IDE or text editor
* Git repository created during kick off

== Steps

=== Building the Application

. Browse to http://start.spring.io[Spring Initializr] and complete the form:
+
Group:: org.example
Artifact:: cities
Name:: cities
Description:: Demo project
Package name:: org.example.cities
Type:: Gradle project
Packaging:: Jar
Java Version:: 1.7
Language:: Java
Spring Boot Version:: 1.1.7
Project Dependencies:: Actuator, JPA, Rest Repositories, Web

+
Then click `Generate`. This will result in a file called `starter.zip` being downloaded to your workstation.

. Create a directory in your github repository to house your code, and unzip `starter.zip` into that directory.

. Optionally generate project files for your favorite IDE by running `gradle idea` or `gradle eclipse`. Then open the project in your editor or IDE of choice.

. Add a runtime dependency on the http://hsqldb.org/[HyperSQL in-memory database] to `build.gradle`:
+
[source,groovy]
----
dependencies {
    // ...
    runtime("org.hsqldb:hsqldb")
}
----

. Create the package `org.example.cities.model` and in that package create the class +City+. Into that file you can paste the following source code, which represents cities based on postal codes, global coordinates, etc:
+
[source,java]
----
@Entity
@Table(name="city")
public class City implements Serializable {
    private static final long serialVersionUID = 1L;

    @Id
    @GeneratedValue
    private long id;

    @Column(nullable = false)
    private String name;

    @Column(nullable = false)
    private String county;

    @Column(nullable = false)
    private String stateCode;

    @Column(nullable = false)
    private String postalCode;

    @Column
    private String latitude;

    @Column
    private String longitude;

    public String getName() { return name; }

    public void setName(String name) { this.name = name; }

    public String getPostalCode() { return postalCode; }

    public void setPostalCode(String postalCode) { this.postalCode = postalCode; }

    public long getId() { return id; }

    public void setId(long id) { this.id = id; }

    public String getStateCode() { return stateCode; }

    public void setStateCode(String stateCode) { this.stateCode = stateCode; }

    public String getCounty() { return county; }

    public void setCounty(String county) { this.county = county; }

    public String getLatitude() { return latitude; }

    public void setLatitude(String latitude) { this.latitude = latitude; }

    public String getLongitude() { return longitude; }

    public void setLongitude(String longitude) { this.longitude = longitude; }
}
----
+
Notice that we're using JPA annotations on the class and its fields. You'll need to use your IDE's features to add the appropriate import statements.

. Create the package `org.example.cities.repo` and in that package create the interface +CityRepository+. Paste the following code and add appropriate imports:
+
[source,java]
----
@RepositoryRestResource(collectionResourceRel = "cities", path = "cities")
public interface CityRepository extends PagingAndSortingRepository<City, Long> {
}
----

. Add JPA and REST Repository support to the `org.example.cities.Application` class that was generated by Spring Initializr.
+
[source,java]
----
@Configuration
@ComponentScan
@EnableAutoConfiguration
@EnableJpaRepositories // <---- Add this
@Import(RepositoryRestMvcConfiguration.class) // <---- And this
public class Application {

    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}
----

. Build the application:
+
[source,bash]
----
$ gradle assemble
----

. Run the application:
+
[source,bash]
----
$ java -jar build/libs/cities-0.0.1-SNAPSHOT.jar
----

. Access the application using +curl+. You'll see that the primary endpoint automatically exposes the ability to page, size, and sort the response JSON.
+
So what have you done? Created four small classes and one build file, resulting in a fully-functional REST microservice. The application's +DataSource+ is created automatically by Spring Boot using the in-memory database because no other +DataSource+ was detected in the project.
+
[source,bash]
----
$ curl -i localhost:8080/cities
HTTP/1.1 200 OK
Server: Apache-Coyote/1.1
X-Application-Context: application
Content-Type: application/hal+json
Transfer-Encoding: chunked
Date: Tue, 27 May 2014 19:34:45 GMT

{
  "_links" : {
    "self" : {
      "href" : "http://localhost:8080/cities{?page,size,sort}",
      "templated" : true
    }
  },
  "page" : {
    "size" : 20,
    "totalElements" : 0,
    "totalPages" : 0,
    "number" : 0
  }
}
----
+
Next we'll import some data.

==== Importing Data

. Shutdown the application.

. Add this link:src/main/resources/import.sql[import.sql] file to `src/main/resources`. This is a dataset containing all of the postal codes in Colorado. This file will automatically be picked up by Hibernate and imported into the in-memory database.

. Build the application:
+
[source,bash]
----
$ gradle assemble
----

. Run the application:
+
[source,bash]
----
$ java -jar build/libs/cities-0.0.1-SNAPSHOT.jar
----

. Access the application again using +curl+. Notice the appropriate hypermedia is included for +next+, +previous+, and +self+. You can also select pages and page size by utilizing +?size=n&page=n+ on the URL string. Finally, you can sort the data utilizing +?sort=fieldName+.
+
[source,bash]
----
$ curl -i localhost:8080/cities
HTTP/1.1 200 OK
Server: Apache-Coyote/1.1
X-Application-Context: application
Content-Type: application/hal+json
Transfer-Encoding: chunked
Date: Tue, 27 May 2014 19:59:58 GMT

{
  "_links" : {
    "next" : {
      "href" : "http://localhost:8080/cities?page=1&size=20"
    },
    "self" : {
      "href" : "http://localhost:8080/cities{?page,size,sort}",
      "templated" : true
    }
  },

  ... RESULTS ...

  "page" : {
    "size" : 20,
    "totalElements" : 662,
    "totalPages" : 34,
    "number" : 0
  }
}
----

. Try the following +curl+ statements to see how the application behaves:
+
[source,bash]
----
$ curl -i "localhost:8080/cities?size=5"
$ curl -i "localhost:8080/cities?size=5&page=3"
$ curl -i "localhost:8080/cities?sort=postalCode,desc"
----

==== FYI: Using Spring Boot Actuator

Try out the following endpoints. The output is omitted here because it can be quite large:

http://localhost:8080/beans:: Dumps all of the beans in the Spring context.
http://localhost:8080/autoconfig:: Dumps all of the auto-configuration performed as part of application bootstrapping.
http://localhost:8080/env:: Dumps the application's shell environment as well as all Java system properties.
http://localhost:8080/metrics:: Dumps all metrics currently being collected by Actuator, primarily response time and access counts for endpoints.
http://localhost:8080/mappings:: Dumps all URI request mappings and the controller methods to which they are mapped.

=== Pushing to Cloud Foundry

==== Pushing via CLI Parameters

Use `cf help` and/or `cf <command> --help` for details on each of the commands below.

. Review the docs: http://docs.pivotal.io/pivotalcf/devguide/deploy-apps/deploy-app.html

. Verify you are logged in and targeted to your PCF instance:
+
[source,bash]
----
$ cf target
----

. Push your application:
+
[source,bash]
----
$ cf push
----

. Verify you can access your application via a curl request:
+
[source,bash]
----
$ curl -i <your-app>/cities
----


==== Using Manifests

Manifests help to automate the deployment.

. Review the documentation: http://docs.pivotal.io/pivotalcf/devguide/deploy-apps/manifest.html

. Create an application manifest in `manifest.yml`.  Minimally, set the name of the app, the amount of memory, the number of instances, and the path to the .jar file.

. The IBM Bluemix team has created a manifest generator app that can also be used:
** Hosted: http://cfmanigen.mybluemix.net/
** Source: https://github.com/IBM-Bluemix/cf-manifest-generator

. Test your manifest by re-pushing your app with no parameters:
+
[source,bash]
----
$ cf push
----

=== Binding Services with Spring Cloud & Profiles

At present we're still using the in-memory database. Let's connect to a MySQL database service provided by Cloud Foundry.

References:

* Spring Cloud: http://projects.spring.io/spring-cloud/
* Spring Profiles: http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/context/annotation/Profile.html

==== Enabling Spring Cloud & Profiles

. Add Spring Cloud and MySQL dependencies to our Gradle build:
+
[source,groovy]
----
dependencies {
    // ....
    compile("org.springframework.cloud:spring-cloud-spring-service-connector:1.0.0.RELEASE")
    compile("org.springframework.cloud:spring-cloud-cloudfoundry-connector:1.0.0.RELEASE")
    runtime("mysql:mysql-connector-java:5.1.25")
}
----

. Since we've added new dependencies, re-run `gradle idea` or `gradle eclipse` to have them added to the IDE classpath.

. Next, let's create the package +org.example.cities.config+ and create in that package the class +CloudDataSourceConfig+. Add the following code:
+
[source,java]
----
@Profile("cloud")
@Configuration
public class CloudDataSourceConfig extends AbstractCloudConfig {
    @Bean
    public DataSource dataSource() {
        return connectionFactory().dataSource();
    }
}
----

. As before, have the IDE import the appropriate dependencies.
+
The `@Profile` annotation will cause this class (which becomes Spring configuration when annotated as `@Configuration`) to be added to the configuration set because of the `SPRING_PROFILES_ACTIVE` environment variable we added earlier. You can still run the application locally (with the default profile) using the embedded database.
+
With this code, Spring Cloud will detect a bound service that is compatible with +DataSource+, read the credentials, and then create a +DataSource+ as appropriate (it will throw an exception otherwise).

. Add the following to `src/main/resources/application.properties` to cause Hibernate to create the database schema and import data at startup. This is done automatically for embedded databases, not for custom ++DataSource++s. Other Hibernate native properties can be set in a similar fashion:
+
[source,java]
----
spring.jpa.hibernate.ddl-auto=create
----

. Build the application:
+
[source,bash]
----
$ gradle assemble
----

. Re-push the application:
+
[source,bash]
----
$ cf push
----

==== Troubleshooting

Did it work?  Let's figure out why not.

. Review the documentation on Troubleshooting: http://docs.pivotal.io/pivotalcf/devguide/deploy-apps/troubleshoot-app-health.html

. What do the recent logs tell you?

==== Manually Creating a Service

. Review the docs on Services:
** http://docs.pivotal.io/pivotalcf/devguide/services/adding-a-service.html
** http://docs.pivotal.io/pivotalcf/devguide/services/managing-services.html

. Create a mysql service instance

. Launch the DB console from the Users Console.  Note the database is empty with zero connections.

==== Manually Binding the Service Instance

. Review the docs on Binding a Service Instance: http://docs.pivotal.io/pivotalcf/devguide/services/bind-service.html

. Bind the instance to your app

. Restart your application to inject the new database.

==== Binding in the Manifest

. Add the services binding to your deployment manifest.

. If you are going to expand the service to leverage different Spring profiles, you should also set the `SPRING_PROFILES_ACTIVE` environment variable to `cloud`.

. Now, manually unbind the service and re-push your app using the manifest.

=== Environment Variables

. Review the document on Environment Variables: http://docs.pivotal.io/pivotalcf/devguide/deploy-apps/environment-variable.html

. What variable shows your mysql service instance?

. How could you set the `SPRING_PROFILES_ACTIVE` variable from the CLI?

=== Scaling

Apps can be scaled via the CLI or the Console.

. Scale your app to 2 instances.
